#!/bin/bash
# System Backup Script
# Generated by Ansible for {{ ansible_hostname }}
# Environment: {{ ansible_environment }}
# Generated: {{ ansible_date_time }}

# Load configuration
source /etc/backup/backup-config.sh

# Function to log messages
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Function to send email notification
send_notification() {
    local subject="$1"
    local message="$2"
    
    if [ "$EMAIL_ENABLED" = "true" ]; then
        echo "$message" | mail -s "$subject" -r "$EMAIL_FROM" "$EMAIL_TO"
        log_message "Notification sent: $subject"
    fi
}

# Function to create backup directory
create_backup_dir() {
    local backup_path="$1"
    mkdir -p "$backup_path"
    chmod 750 "$backup_path"
    chown $BACKUP_USER:$BACKUP_GROUP "$backup_path"
}

# Function to backup system configuration
backup_system_config() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="system_config_${timestamp}"
    local backup_path="${SYSTEM_BACKUP_DIR}/${backup_name}"
    
    log_message "Starting system configuration backup: $backup_name"
    
    create_backup_dir "$backup_path"
    
    # Backup critical system files
    local files_to_backup=(
        "/etc/passwd"
        "/etc/group"
        "/etc/shadow"
        "/etc/gshadow"
        "/etc/fstab"
        "/etc/hosts"
        "/etc/resolv.conf"
        "/etc/hostname"
        "/etc/ssh/sshd_config"
        "/etc/crontab"
        "/var/spool/cron"
        "/etc/sysctl.conf"
        "/etc/ufw"
        "/etc/iptables"
        "/etc/fail2ban"
    )
    
    for file in "${files_to_backup[@]}"; do
        if [ -e "$file" ]; then
            local dest_dir="$backup_path$(dirname "$file")"
            mkdir -p "$dest_dir"
            cp -a "$file" "$dest_dir/" 2>/dev/null || log_message "Warning: Could not backup $file"
        fi
    done
    
    # Backup package list
    if command -v dpkg >/dev/null 2>&1; then
        dpkg --get-selections > "$backup_path/dpkg-selections.txt"
    elif command -v rpm >/dev/null 2>&1; then
        rpm -qa > "$backup_path/rpm-packages.txt"
    fi
    
    # Backup installed services
    systemctl list-units --type=service --state=running > "$backup_path/running-services.txt"
    systemctl list-unit-files --type=service --state=enabled > "$backup_path/enabled-services.txt"
    
    # Network configuration
    if command -v ip >/dev/null 2>&1; then
        ip addr show > "$backup_path/network-interfaces.txt"
        ip route show > "$backup_path/routes.txt"
    fi
    
    # Compress backup
    local archive_file="${SYSTEM_BACKUP_DIR}/${backup_name}.tar.gz"
    tar -czf "$archive_file" -C "$SYSTEM_BACKUP_DIR" "$backup_name"
    rm -rf "$backup_path"
    
    # Set permissions
    chmod 640 "$archive_file"
    chown $BACKUP_USER:$BACKUP_GROUP "$archive_file"
    
    log_message "System configuration backup completed: $archive_file"
    echo "$archive_file"
}

# Function to backup disk layout
backup_disk_layout() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="disk_layout_${timestamp}"
    local backup_path="${SYSTEM_BACKUP_DIR}/${backup_name}"
    
    log_message "Starting disk layout backup: $backup_name"
    
    create_backup_dir "$backup_path"
    
    # Partition information
    fdisk -l > "$backup_path/fdisk-l.txt" 2>/dev/null
    lsblk > "$backup_path/lsblk.txt"
    blkid > "$backup_path/blkid.txt"
    
    # Filesystem information
    df -h > "$backup_path/df-h.txt"
    mount > "$backup_path/mount.txt"
    
    # LVM information (if available)
    if command -v lvdisplay >/dev/null 2>&1; then
        pvdisplay > "$backup_path/pvdisplay.txt" 2>/dev/null
        vgdisplay > "$backup_path/vgdisplay.txt" 2>/dev/null
        lvdisplay > "$backup_path/lvdisplay.txt" 2>/dev/null
    fi
    
    # RAID information (if available)
    if [ -f /proc/mdstat ]; then
        cat /proc/mdstat > "$backup_path/mdstat.txt"
    fi
    
    # Compress backup
    local archive_file="${SYSTEM_BACKUP_DIR}/${backup_name}.tar.gz"
    tar -czf "$archive_file" -C "$SYSTEM_BACKUP_DIR" "$backup_name"
    rm -rf "$backup_path"
    
    chmod 640 "$archive_file"
    chown $BACKUP_USER:$BACKUP_GROUP "$archive_file"
    
    log_message "Disk layout backup completed: $archive_file"
    echo "$archive_file"
}

# Function to backup system state
backup_system_state() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="system_state_${timestamp}"
    local backup_path="${SYSTEM_BACKUP_DIR}/${backup_name}"
    
    log_message "Starting system state backup: $backup_name"
    
    create_backup_dir "$backup_path"
    
    # System information
    uname -a > "$backup_path/uname.txt"
    lsb_release -a > "$backup_path/lsb-release.txt" 2>/dev/null
    cat /etc/os-release > "$backup_path/os-release.txt" 2>/dev/null
    
    # Hardware information
    lscpu > "$backup_path/cpu-info.txt"
    free -h > "$backup_path/memory-info.txt"
    lspci > "$backup_path/pci-devices.txt"
    lsusb > "$backup_path/usb-devices.txt"
    
    # Kernel modules
    lsmod > "$backup_path/kernel-modules.txt"
    
    # System limits
    ulimit -a > "$backup_path/ulimit.txt"
    cat /etc/security/limits.conf > "$backup_path/security-limits.txt" 2>/dev/null
    
    # Environment variables
    env > "$backup_path/environment.txt"
    
    # Compress backup
    local archive_file="${SYSTEM_BACKUP_DIR}/${backup_name}.tar.gz"
    tar -czf "$archive_file" -C "$SYSTEM_BACKUP_DIR" "$backup_name"
    rm -rf "$backup_path"
    
    chmod 640 "$archive_file"
    chown $BACKUP_USER:$BACKUP_GROUP "$archive_file"
    
    log_message "System state backup completed: $archive_file"
    echo "$archive_file"
}

# Function to encrypt backup
encrypt_backup() {
    local file="$1"
    
    if [ "$ENCRYPTION" = "true" ] && [ -f "$KEY_FILE" ]; then
        local encrypted_file="${file}.enc"
        openssl enc -aes-256-cbc -salt -in "$file" -out "$encrypted_file" -pass file:"$KEY_FILE"
        
        if [ $? -eq 0 ]; then
            rm "$file"
            log_message "Backup encrypted: $encrypted_file"
            echo "$encrypted_file"
            return 0
        else
            log_message "ERROR: Failed to encrypt backup: $file"
            return 1
        fi
    fi
    
    echo "$file"
}

# Function to upload to S3
upload_to_s3() {
    local file="$1"
    
    if [ "$S3_ENABLED" = "true" ] && [ -n "$S3_BUCKET" ]; then
        local s3_path="s3://${S3_BUCKET}/system/$(basename "$file")"
        
        if [ -n "$S3_ENDPOINT" ]; then
            aws --endpoint-url "$S3_ENDPOINT" s3 cp "$file" "$s3_path" --storage-class "$S3_STORAGE_CLASS"
        else
            aws s3 cp "$file" "$s3_path" --storage-class "$S3_STORAGE_CLASS"
        fi
        
        if [ $? -eq 0 ]; then
            log_message "Backup uploaded to S3: $s3_path"
            return 0
        else
            log_message "ERROR: Failed to upload to S3: $s3_path"
            return 1
        fi
    fi
    
    return 0
}

# Main backup function
main() {
    local backup_files=()
    local start_time=$(date +%s)
    
    log_message "Starting system backup on {{ ansible_hostname }}"
    
    # Check if system backup is enabled
    if [ "$SYSTEM_BACKUP_ENABLED" != "true" ]; then
        log_message "System backup is disabled"
        return 0
    fi
    
    # Create backup directories
    create_backup_dir "$SYSTEM_BACKUP_DIR"
    
    # Run system backups
    local config_backup=$(backup_system_config)
    if [ $? -eq 0 ]; then
        backup_files+=("$config_backup")
    fi
    
    local disk_backup=$(backup_disk_layout)
    if [ $? -eq 0 ]; then
        backup_files+=("$disk_backup")
    fi
    
    local state_backup=$(backup_system_state)
    if [ $? -eq 0 ]; then
        backup_files+=("$state_backup")
    fi
    
    # Process backup files
    local successful_uploads=0
    local failed_uploads=0
    
    for backup_file in "${backup_files[@]}"; do
        # Encrypt backup
        local processed_file=$(encrypt_backup "$backup_file")
        if [ $? -eq 0 ]; then
            # Upload to S3
            if upload_to_s3 "$processed_file"; then
                ((successful_uploads++))
            else
                ((failed_uploads++))
            fi
        else
            ((failed_uploads++))
        fi
    done
    
    # Calculate duration
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local duration_min=$((duration / 60))
    local duration_sec=$((duration % 60))
    
    # Send notification
    local subject="System Backup Report - {{ ansible_hostname }}"
    local message="System backup completed in ${duration_min}m ${duration_sec}s
Successful uploads: $successful_uploads
Failed uploads: $failed_uploads
Total files processed: ${#backup_files[@]}
Server: {{ ansible_hostname }}"
    
    send_notification "$subject" "$message"
    
    log_message "System backup completed successfully in ${duration_min}m ${duration_sec}s"
    
    return 0
}

# Create log directory
mkdir -p "$(dirname "$LOG_FILE")"

# Run main function
main "$@"
