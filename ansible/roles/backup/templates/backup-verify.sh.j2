#!/bin/bash
# Backup Verification Script
# Generated by Ansible for {{ ansible_hostname }}
# Environment: {{ ansible_environment }}
# Generated: {{ ansible_date_time }}

# Load configuration
source /etc/backup/backup-config.sh

# Function to log messages
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Function to send email notification
send_notification() {
    local subject="$1"
    local message="$2"
    
    if [ "$EMAIL_ENABLED" = "true" ]; then
        echo "$message" | mail -s "$subject" -r "$EMAIL_FROM" "$EMAIL_TO"
        log_message "Notification sent: $subject"
    fi
}

# Function to verify file integrity
verify_file_integrity() {
    local file="$1"
    
    if [ ! -f "$file" ]; then
        log_message "ERROR: File not found: $file"
        return 1
    fi
    
    # Check file size
    local file_size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
    if [ "$file_size" -eq 0 ]; then
        log_message "ERROR: Empty file: $file"
        return 1
    fi
    
    # Check if file is readable
    if [ ! -r "$file" ]; then
        log_message "ERROR: File not readable: $file"
        return 1
    fi
    
    # Verify compressed file integrity
    case "$file" in
        *.gz)
            if ! gzip -t "$file" >/dev/null 2>&1; then
                log_message "ERROR: Corrupted gzip file: $file"
                return 1
            fi
            ;;
        *.tar.gz)
            if ! tar -tzf "$file" >/dev/null 2>&1; then
                log_message "ERROR: Corrupted tar.gz file: $file"
                return 1
            fi
            ;;
        *.zip)
            if ! unzip -t "$file" >/dev/null 2>&1; then
                log_message "ERROR: Corrupted zip file: $file"
                return 1
            fi
            ;;
    esac
    
    log_message "File integrity verified: $file (${file_size} bytes)"
    return 0
}

# Function to verify encrypted backup
verify_encrypted_backup() {
    local file="$1"
    
    if [ ! -f "$file" ]; then
        log_message "ERROR: Encrypted file not found: $file"
        return 1
    fi
    
    if [ ! -f "$KEY_FILE" ]; then
        log_message "ERROR: Encryption key not found: $KEY_FILE"
        return 1
    fi
    
    # Test decryption (just verify, don't extract)
    local temp_file="/tmp/verify_backup_$$"
    
    openssl enc -aes-256-cbc -d -in "$file" -out "$temp_file" -pass file:"$KEY_FILE" >/dev/null 2>&1
    
    local result=$?
    rm -f "$temp_file"
    
    if [ $result -eq 0 ]; then
        log_message "Encrypted backup verified: $file"
        return 0
    else
        log_message "ERROR: Encrypted backup verification failed: $file"
        return 1
    fi
}

# Function to verify S3 backup
verify_s3_backup() {
    local s3_path="$1"
    local local_file="$2"
    
    if [ -n "$S3_BUCKET" ]; then
        # Check if file exists in S3
        if [ -n "$S3_ENDPOINT" ]; then
            aws --endpoint-url "$S3_ENDPOINT" s3 ls "$s3_path" >/dev/null 2>&1
        else
            aws s3 ls "$s3_path" >/dev/null 2>&1
        fi
        
        if [ $? -ne 0 ]; then
            log_message "ERROR: S3 file not found: $s3_path"
            return 1
        fi
        
        # Compare file sizes
        local s3_size=$(aws s3api head-object --bucket "$S3_BUCKET" --key "$(basename "$s3_path" | sed 's|^s3://[^/]*/||')" --query 'ContentLength' --output text 2>/dev/null)
        local local_size=$(stat -c%s "$local_file" 2>/dev/null || stat -f%z "$local_file" 2>/dev/null)
        
        if [ -n "$s3_size" ] && [ -n "$local_size" ] && [ "$s3_size" = "$local_size" ]; then
            log_message "S3 backup verified: $s3_path (${local_size} bytes)"
            return 0
        else
            log_message "ERROR: S3 backup size mismatch - S3: $s3_size, Local: $local_size"
            return 1
        fi
    else
        log_message "WARNING: S3 verification skipped (S3 not configured)"
        return 0
    fi
}

# Function to verify database backup
verify_database_backup() {
    local backup_file="$1"
    
    log_message "Verifying database backup: $backup_file"
    
    # Create temporary directory for verification
    local temp_dir="/tmp/db_verify_$$"
    mkdir -p "$temp_dir"
    
    local verification_passed=false
    
    # Handle encrypted files
    local verify_file="$backup_file"
    if [[ "$backup_file" == *.enc ]]; then
        verify_file="${backup_file%.enc}"
        
        if ! verify_encrypted_backup "$backup_file"; then
            rm -rf "$temp_dir"
            return 1
        fi
        
        # Decrypt to temp file for verification
        openssl enc -aes-256-cbc -d -in "$backup_file" -out "$verify_file" -pass file:"$KEY_FILE" >/dev/null 2>&1
    fi
    
    # Verify based on file type
    case "$verify_file" in
        *.sql.gz)
            # Test MySQL backup
            gunzip -c "$verify_file" | head -10 >/dev/null 2>&1
            if [ $? -eq 0 ]; then
                verification_passed=true
                log_message "MySQL backup structure verified"
            fi
            ;;
        *.tar.gz)
            # Test MongoDB or SQLite backup
            tar -tzf "$verify_file" >/dev/null 2>&1
            if [ $? -eq 0 ]; then
                verification_passed=true
                log_message "Archive backup structure verified"
            fi
            ;;
    esac
    
    # Cleanup
    rm -rf "$temp_dir"
    if [[ "$backup_file" == *.enc ]]; then
        rm -f "$verify_file"
    fi
    
    if [ "$verification_passed" = true ]; then
        return 0
    else
        log_message "ERROR: Database backup verification failed: $backup_file"
        return 1
    fi
}

# Function to verify backup by sampling
verify_by_sampling() {
    local backup_file="$1"
    local sample_percentage="$2"
    
    if [ ! -f "$backup_file" ]; then
        log_message "ERROR: Backup file not found: $backup_file"
        return 1
    fi
    
    log_message "Sampling backup verification: $backup_file (${sample_percentage}%)"
    
    # Extract small sample for verification
    local temp_file="/tmp/sample_verify_$$"
    local sample_size=$(( $(stat -c%s "$backup_file" 2>/dev/null || stat -f%z "$backup_file" 2>/dev/null) * sample_percentage / 100 ))
    
    if [ $sample_size -lt 1024 ]; then
        sample_size=1024  # Minimum 1KB sample
    fi
    
    # Extract sample
    dd if="$backup_file" of="$temp_file" bs=1 count=$sample_size 2>/dev/null
    
    # Check if sample is readable and not corrupted
    local verification_passed=false
    
    case "$backup_file" in
        *.gz)
            if gzip -c "$temp_file" | head -1 >/dev/null 2>&1; then
                verification_passed=true
            fi
            ;;
        *)
            if [ -s "$temp_file" ]; then
                verification_passed=true
            fi
            ;;
    esac
    
    rm -f "$temp_file"
    
    if [ "$verification_passed" = true ]; then
        log_message "Backup sample verification passed: $backup_file"
        return 0
    else
        log_message "ERROR: Backup sample verification failed: $backup_file"
        return 1
    fi
}

# Function to generate verification report
generate_verification_report() {
    local report_file="/tmp/backup_verification_report_$$"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    cat > "$report_file" << EOF
Backup Verification Report
Generated: $timestamp
Server: {{ ansible_hostname }}
Verification Mode: $1

Summary:
Total Backups Verified: $2
Successful Verifications: $3
Failed Verifications: $4
Success Rate: $5%

Verification Results:
$6

Recommendations:
$7
EOF

    echo "$(<"$report_file")"
    rm -f "$report_file"
}

# Main verification function
main() {
    local verification_type="${1:-all}"
    local total_backups=0
    local successful_verifications=0
    local failed_verifications=0
    local verification_results=""
    local recommendations=""
    
    log_message "Starting backup verification: $verification_type on {{ ansible_hostname }}"
    
    # Check if verification is enabled
    if [ "$VERIFY_ENABLED" != "true" ]; then
        log_message "Backup verification is disabled"
        return 0
    fi
    
    case "$verification_type" in
        recent)
            # Verify recent backups (last 24 hours)
            log_message "Verifying recent backups"
            
            local backup_files=$(find "$BACKUP_DIR" -name "*.tar.gz" -o -name "*.sql.gz" -o -name "*.enc" -mtime -1 2>/dev/null)
            
            for backup_file in $backup_files; do
                ((total_backups++))
                
                if verify_file_integrity "$backup_file"; then
                    ((successful_verifications++))
                    verification_results="${verification_results}✓ $backup_file: PASSED\n"
                else
                    ((failed_verifications++))
                    verification_results="${verification_results}✗ $backup_file: FAILED\n"
                    recommendations="${recommendations}- Review failed backup: $backup_file\n"
                fi
            done
            ;;
        s3)
            # Verify S3 backups
            log_message "Verifying S3 backups"
            
            if [ -n "$S3_BUCKET" ]; then
                local s3_files=$(aws s3 ls "s3://$S3_BUCKET/" --recursive | awk '{print $4}' | head -10)
                
                for s3_file in $s3_files; do
                    ((total_backups++))
                    
                    # Find corresponding local file for comparison
                    local local_file=$(find "$BACKUP_DIR" -name "$(basename "$s3_file")" 2>/dev/null | head -1)
                    
                    if [ -n "$local_file" ]; then
                        if verify_s3_backup "s3://$S3_BUCKET/$s3_file" "$local_file"; then
                            ((successful_verifications++))
                            verification_results="${verification_results}✓ $s3_file: PASSED\n"
                        else
                            ((failed_verifications++))
                            verification_results="${verification_results}✗ $s3_file: FAILED\n"
                            recommendations="${recommendations}- Check S3 upload for: $s3_file\n"
                        fi
                    else
                        verification_results="${verification_results}? $s3_file: LOCAL FILE MISSING\n"
                        recommendations="${recommendations}- Local file missing for S3 backup: $s3_file\n"
                    fi
                done
            else
                log_message "WARNING: S3 verification skipped (S3 not configured)"
            fi
            ;;
        database)
            # Verify database backups specifically
            log_message "Verifying database backups"
            
            local db_backups=$(find "$DB_BACKUP_DIR" -name "*.sql.gz" -o -name "*.tar.gz" -mtime -7 2>/dev/null)
            
            for db_backup in $db_backups; do
                ((total_backups++))
                
                if verify_database_backup "$db_backup"; then
                    ((successful_verifications++))
                    verification_results="${verification_results}✓ $(basename $db_backup): PASSED\n"
                else
                    ((failed_verifications++))
                    verification_results="${verification_results}✗ $(basename $db_backup): FAILED\n"
                    recommendations="${recommendations}- Review failed database backup: $(basename $db_backup)\n"
                fi
            done
            ;;
        *)
            # Verify all backups with sampling
            log_message "Verifying all backups with sampling"
            
            local all_backups=$(find "$BACKUP_DIR" -name "*.tar.gz" -o -name "*.sql.gz" -o -name "*.enc" -mtime -7 2>/dev/null)
            
            for backup_file in $all_backups; do
                ((total_backups++))
                
                if verify_by_sampling "$backup_file" "$VERIFY_SAMPLE_SIZE"; then
                    ((successful_verifications++))
                    verification_results="${verification_results}✓ $(basename $backup_file): PASSED\n"
                else
                    ((failed_verifications++))
                    verification_results="${verification_results}✗ $(basename $backup_file): FAILED\n"
                    recommendations="${recommendations}- Review failed backup: $(basename $backup_file)\n"
                fi
            done
            ;;
    esac
    
    # Calculate success rate
    local success_rate=0
    if [ $total_backups -gt 0 ]; then
        success_rate=$((successful_verifications * 100 / total_backups))
    fi
    
    # Add recommendations
    if [ $success_rate -lt 100 ]; then
        recommendations="${recommendations}\n- Review backup processes and schedules\n"
        recommendations="${recommendations}- Check available disk space\n"
        recommendations="${recommendations}- Verify encryption key integrity\n"
    fi
    
    if [ $failed_verifications -gt 0 ]; then
        recommendations="${recommendations}\n- Investigate root cause of backup failures\n"
        recommendations="${recommendations}- Consider implementing additional monitoring\n"
    fi
    
    # Generate and send report
    local report=$(generate_verification_report "$verification_type" "$total_backups" "$successful_verifications" "$failed_verifications" "$success_rate" "$verification_results" "$recommendations")
    
    log_message "Backup verification completed - Success rate: ${success_rate}%"
    
    # Send notification
    local subject="Backup Verification Report - {{ ansible_hostname }}"
    local message="Backup verification completed on {{ ansible_hostname }}
Type: $verification_type
Total: $total_backups, Successful: $successful_verifications, Failed: $failed_verifications
Success Rate: ${success_rate}%

$report"
    
    send_notification "$subject" "$message"
    
    return $failed_verifications
}

# Create log directory
mkdir -p "$(dirname "$LOG_FILE")"

# Run main function
main "$@"
