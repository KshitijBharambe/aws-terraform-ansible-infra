#!/bin/bash
# Database Backup Script
# Generated by Ansible for {{ ansible_hostname }}
# Environment: {{ ansible_environment }}
# Generated: {{ ansible_date_time }}

# Load configuration
source /etc/backup/backup-config.sh

# Function to log messages
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Function to send email notification
send_notification() {
    local subject="$1"
    local message="$2"
    
    if [ "$EMAIL_ENABLED" = "true" ]; then
        echo "$message" | mail -s "$subject" -r "$EMAIL_FROM" "$EMAIL_TO"
        log_message "Notification sent: $subject"
    fi
}

# Function to create backup directory
create_backup_dir() {
    local backup_path="$1"
    mkdir -p "$backup_path"
    chmod 750 "$backup_path"
    chown $BACKUP_USER:$BACKUP_GROUP "$backup_path"
}

# Function to backup MySQL/MariaDB
backup_mysql() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="mysql_backup_${timestamp}"
    local backup_file="${DB_BACKUP_DIR}/${backup_name}.sql.gz"
    
    log_message "Starting MySQL backup: $backup_name"
    
    create_backup_dir "$DB_BACKUP_DIR"
    
    # Check MySQL connectivity
    if ! mysql -h "$DB_HOST" -u "$DB_USER" -e "SELECT 1" >/dev/null 2>&1; then
        log_message "ERROR: Cannot connect to MySQL server"
        return 1
    fi
    
    # Get list of databases
    local databases=$(mysql -h "$DB_HOST" -u "$DB_USER" -e "SHOW DATABASES" | grep -v Database | grep -v information_schema | grep -v performance_schema | grep -v mysql)
    
    for db in $databases; do
        local db_backup_file="${DB_BACKUP_DIR}/${backup_name}_${db}.sql.gz"
        
        log_message "Backing up database: $db"
        
        # Backup individual database
        mysqldump -h "$DB_HOST" -u "$DB_USER" \
            --single-transaction \
            --routines \
            --triggers \
            --events \
            --hex-blob \
            --opt \
            --quick \
            --lock-tables=false \
            "$db" | gzip > "$db_backup_file"
        
        if [ ${PIPESTATUS[0]} -eq 0 ]; then
            chmod 640 "$db_backup_file"
            chown $BACKUP_USER:$BACKUP_GROUP "$db_backup_file"
            log_message "Database backup completed: $db -> $db_backup_file"
        else
            log_message "ERROR: Failed to backup database: $db"
            rm -f "$db_backup_file"
        fi
    done
    
    # Backup all databases in one file
    local all_backup_file="${DB_BACKUP_DIR}/${backup_name}_all.sql.gz"
    mysqldump -h "$DB_HOST" -u "$DB_USER" \
        --single-transaction \
        --routines \
        --triggers \
        --events \
        --hex-blob \
        --opt \
        --quick \
        --lock-tables=false \
        --all-databases | gzip > "$all_backup_file"
    
    if [ ${PIPESTATUS[0]} -eq 0 ]; then
        chmod 640 "$all_backup_file"
        chown $BACKUP_USER:$BACKUP_GROUP "$all_backup_file"
        log_message "All databases backup completed: $all_backup_file"
        echo "$all_backup_file"
        return 0
    else
        log_message "ERROR: Failed to backup all databases"
        rm -f "$all_backup_file"
        return 1
    fi
}

# Function to backup PostgreSQL
backup_postgresql() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="postgresql_backup_${timestamp}"
    local backup_file="${DB_BACKUP_DIR}/${backup_name}.sql.gz"
    
    log_message "Starting PostgreSQL backup: $backup_name"
    
    create_backup_dir "$DB_BACKUP_DIR"
    
    # Check PostgreSQL connectivity
    if ! pg_isready -h "$DB_HOST" >/dev/null 2>&1; then
        log_message "ERROR: Cannot connect to PostgreSQL server"
        return 1
    fi
    
    # Get list of databases
    local databases=$(psql -h "$DB_HOST" -U "$DB_USER" -d postgres -t -c "SELECT datname FROM pg_database WHERE NOT datistemplate AND datallowconn" | tr -d ' ')
    
    for db in $databases; do
        local db_backup_file="${DB_BACKUP_DIR}/${backup_name}_${db}.sql.gz"
        
        log_message "Backing up database: $db"
        
        # Backup individual database
        pg_dump -h "$DB_HOST" -U "$DB_USER" \
            --verbose \
            --no-password \
            --clean \
            --if-exists \
            --format=custom \
            --compress=9 \
            "$db" | gzip > "$db_backup_file"
        
        if [ ${PIPESTATUS[0]} -eq 0 ]; then
            chmod 640 "$db_backup_file"
            chown $BACKUP_USER:$BACKUP_GROUP "$db_backup_file"
            log_message "Database backup completed: $db -> $db_backup_file"
        else
            log_message "ERROR: Failed to backup database: $db"
            rm -f "$db_backup_file"
        fi
    done
    
    # Backup all databases
    local all_backup_file="${DB_BACKUP_DIR}/${backup_name}_all.sql.gz"
    pg_dumpall -h "$DB_HOST" -U "$DB_USER" \
        --verbose \
        --no-password \
        --clean \
        --if-exists | gzip > "$all_backup_file"
    
    if [ ${PIPESTATUS[0]} -eq 0 ]; then
        chmod 640 "$all_backup_file"
        chown $BACKUP_USER:$BACKUP_GROUP "$all_backup_file"
        log_message "All databases backup completed: $all_backup_file"
        echo "$all_backup_file"
        return 0
    else
        log_message "ERROR: Failed to backup all databases"
        rm -f "$all_backup_file"
        return 1
    fi
}

# Function to backup MongoDB
backup_mongodb() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="mongodb_backup_${timestamp}"
    local backup_path="${DB_BACKUP_DIR}/${backup_name}"
    
    log_message "Starting MongoDB backup: $backup_name"
    
    create_backup_dir "$backup_path"
    
    # Check MongoDB connectivity
    if ! mongosh --host "$DB_HOST" --eval "db.adminCommand('ismaster')" >/dev/null 2>&1; then
        log_message "ERROR: Cannot connect to MongoDB server"
        return 1
    fi
    
    # Backup all databases
    mongodump --host "$DB_HOST" \
        --out "$backup_path" \
        --gzip \
        --oplog
    
    if [ $? -eq 0 ]; then
        # Create archive
        local archive_file="${DB_BACKUP_DIR}/${backup_name}.tar.gz"
        tar -czf "$archive_file" -C "$DB_BACKUP_DIR" "$backup_name"
        rm -rf "$backup_path"
        
        chmod 640 "$archive_file"
        chown $BACKUP_USER:$BACKUP_GROUP "$archive_file"
        
        log_message "MongoDB backup completed: $archive_file"
        echo "$archive_file"
        return 0
    else
        log_message "ERROR: Failed to backup MongoDB"
        rm -rf "$backup_path"
        return 1
    fi
}

# Function to backup SQLite
backup_sqlite() {
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_name="sqlite_backup_${timestamp}"
    local backup_file="${DB_BACKUP_DIR}/${backup_name}.tar.gz"
    
    log_message "Starting SQLite backup: $backup_name"
    
    create_backup_dir "$DB_BACKUP_DIR"
    
    # Find SQLite files (common locations)
    local sqlite_files=(
        "/var/lib/sqlite/*.db"
        "/var/www/html/data/*.db"
        "/opt/application/data/*.db"
    )
    
    local temp_dir="${DB_BACKUP_DIR}/${backup_name}"
    mkdir -p "$temp_dir"
    
    local found_files=false
    
    for pattern in "${sqlite_files[@]}"; do
        for file in $pattern; do
            if [ -f "$file" ]; then
                log_message "Backing up SQLite file: $file"
                
                # Use SQLite backup command for consistency
                local filename=$(basename "$file")
                sqlite3 "$file" ".backup $temp_dir/$filename"
                
                if [ $? -eq 0 ]; then
                    found_files=true
                    log_message "SQLite file backed up: $file -> $temp_dir/$filename"
                else
                    log_message "ERROR: Failed to backup SQLite file: $file"
                fi
            fi
        done
    done
    
    if [ "$found_files" = true ]; then
        # Create archive
        tar -czf "$backup_file" -C "$DB_BACKUP_DIR" "$backup_name"
        rm -rf "$temp_dir"
        
        chmod 640 "$backup_file"
        chown $BACKUP_USER:$BACKUP_GROUP "$backup_file"
        
        log_message "SQLite backup completed: $backup_file"
        echo "$backup_file"
        return 0
    else
        log_message "No SQLite files found for backup"
        rm -rf "$temp_dir"
        return 1
    fi
}

# Function to encrypt backup
encrypt_backup() {
    local file="$1"
    
    if [ "$ENCRYPTION" = "true" ] && [ -f "$KEY_FILE" ]; then
        local encrypted_file="${file}.enc"
        openssl enc -aes-256-cbc -salt -in "$file" -out "$encrypted_file" -pass file:"$KEY_FILE"
        
        if [ $? -eq 0 ]; then
            rm "$file"
            log_message "Database backup encrypted: $encrypted_file"
            echo "$encrypted_file"
            return 0
        else
            log_message "ERROR: Failed to encrypt database backup: $file"
            return 1
        fi
    fi
    
    echo "$file"
}

# Function to upload to S3
upload_to_s3() {
    local file="$1"
    
    if [ "$S3_ENABLED" = "true" ] && [ -n "$S3_BUCKET" ]; then
        local s3_path="s3://${S3_BUCKET}/database/$(basename "$file")"
        
        if [ -n "$S3_ENDPOINT" ]; then
            aws --endpoint-url "$S3_ENDPOINT" s3 cp "$file" "$s3_path" --storage-class "$S3_STORAGE_CLASS"
        else
            aws s3 cp "$file" "$s3_path" --storage-class "$S3_STORAGE_CLASS"
        fi
        
        if [ $? -eq 0 ]; then
            log_message "Database backup uploaded to S3: $s3_path"
            return 0
        else
            log_message "ERROR: Failed to upload database backup to S3: $s3_path"
            return 1
        fi
    fi
    
    return 0
}

# Function to detect database type and run appropriate backup
backup_database() {
    local db_type="${DB_TYPE:-auto}"
    
    case "$db_type" in
        mysql|mariadb)
            backup_mysql
            ;;
        postgresql|postgres)
            backup_postgresql
            ;;
        mongodb|mongo)
            backup_mongodb
            ;;
        sqlite)
            backup_sqlite
            ;;
        auto)
            # Auto-detect database type
            if command -v mysql >/dev/null 2>&1 && mysql -h "$DB_HOST" -u "$DB_USER" -e "SELECT 1" >/dev/null 2>&1; then
                backup_mysql
            elif command -v psql >/dev/null 2>&1 && pg_isready -h "$DB_HOST" >/dev/null 2>&1; then
                backup_postgresql
            elif command -v mongosh >/dev/null 2>&1 && mongosh --host "$DB_HOST" --eval "db.adminCommand('ismaster')" >/dev/null 2>&1; then
                backup_mongodb
            else
                backup_sqlite
            fi
            ;;
        *)
            log_message "ERROR: Unsupported database type: $db_type"
            return 1
            ;;
    esac
}

# Main backup function
main() {
    local backup_files=()
    local start_time=$(date +%s)
    
    log_message "Starting database backup on {{ ansible_hostname }}"
    
    # Check if database backup is enabled
    if [ "$DB_BACKUP_ENABLED" != "true" ]; then
        log_message "Database backup is disabled"
        return 0
    fi
    
    # Create backup directories
    create_backup_dir "$DB_BACKUP_DIR"
    
    # Run database backup
    local backup_file=$(backup_database)
    if [ $? -eq 0 ] && [ -n "$backup_file" ]; then
        backup_files+=("$backup_file")
        
        # Encrypt backup
        local processed_file=$(encrypt_backup "$backup_file")
        if [ $? -eq 0 ]; then
            # Upload to S3
            if upload_to_s3 "$processed_file"; then
                local success_count=1
            else
                local success_count=0
            fi
        else
            local success_count=0
        fi
    else
        local success_count=0
    fi
    
    # Calculate duration
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local duration_min=$((duration / 60))
    local duration_sec=$((duration % 60))
    
    # Send notification
    local subject="Database Backup Report - {{ ansible_hostname }}"
    local message="Database backup completed in ${duration_min}m ${duration_sec}s
Successful backups: $success_count
Failed backups: $((1 - success_count))
Server: {{ ansible_hostname }}"
    
    send_notification "$subject" "$message"
    
    log_message "Database backup completed in ${duration_min}m ${duration_sec}s"
    
    return 0
}

# Create log directory
mkdir -p "$(dirname "$LOG_FILE")"

# Run main function
main "$@"
